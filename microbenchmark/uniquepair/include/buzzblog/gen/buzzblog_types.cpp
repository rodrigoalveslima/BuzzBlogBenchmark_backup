/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "buzzblog_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace gen {


TAccount::~TAccount() noexcept {
}


void TAccount::__set_id(const int32_t val) {
  this->id = val;
}

void TAccount::__set_created_at(const int32_t val) {
  this->created_at = val;
}

void TAccount::__set_active(const bool val) {
  this->active = val;
}

void TAccount::__set_username(const std::string& val) {
  this->username = val;
}

void TAccount::__set_first_name(const std::string& val) {
  this->first_name = val;
}

void TAccount::__set_last_name(const std::string& val) {
  this->last_name = val;
}

void TAccount::__set_follows_you(const bool val) {
  this->follows_you = val;
__isset.follows_you = true;
}

void TAccount::__set_followed_by_you(const bool val) {
  this->followed_by_you = val;
__isset.followed_by_you = true;
}

void TAccount::__set_n_followers(const int32_t val) {
  this->n_followers = val;
__isset.n_followers = true;
}

void TAccount::__set_n_following(const int32_t val) {
  this->n_following = val;
__isset.n_following = true;
}

void TAccount::__set_n_posts(const int32_t val) {
  this->n_posts = val;
__isset.n_posts = true;
}

void TAccount::__set_n_likes(const int32_t val) {
  this->n_likes = val;
__isset.n_likes = true;
}
std::ostream& operator<<(std::ostream& out, const TAccount& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAccount::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_created_at = false;
  bool isset_active = false;
  bool isset_username = false;
  bool isset_first_name = false;
  bool isset_last_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->created_at);
          isset_created_at = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->active);
          isset_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          isset_username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->first_name);
          isset_first_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->last_name);
          isset_last_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->follows_you);
          this->__isset.follows_you = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->followed_by_you);
          this->__isset.followed_by_you = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->n_followers);
          this->__isset.n_followers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->n_following);
          this->__isset.n_following = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->n_posts);
          this->__isset.n_posts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->n_likes);
          this->__isset.n_likes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_created_at)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_active)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_username)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_first_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_last_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAccount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAccount");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("created_at", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->created_at);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("active", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->active);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->first_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->last_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.follows_you) {
    xfer += oprot->writeFieldBegin("follows_you", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->follows_you);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.followed_by_you) {
    xfer += oprot->writeFieldBegin("followed_by_you", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->followed_by_you);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.n_followers) {
    xfer += oprot->writeFieldBegin("n_followers", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->n_followers);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.n_following) {
    xfer += oprot->writeFieldBegin("n_following", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->n_following);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.n_posts) {
    xfer += oprot->writeFieldBegin("n_posts", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->n_posts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.n_likes) {
    xfer += oprot->writeFieldBegin("n_likes", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->n_likes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAccount &a, TAccount &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.created_at, b.created_at);
  swap(a.active, b.active);
  swap(a.username, b.username);
  swap(a.first_name, b.first_name);
  swap(a.last_name, b.last_name);
  swap(a.follows_you, b.follows_you);
  swap(a.followed_by_you, b.followed_by_you);
  swap(a.n_followers, b.n_followers);
  swap(a.n_following, b.n_following);
  swap(a.n_posts, b.n_posts);
  swap(a.n_likes, b.n_likes);
  swap(a.__isset, b.__isset);
}

TAccount::TAccount(const TAccount& other0) {
  id = other0.id;
  created_at = other0.created_at;
  active = other0.active;
  username = other0.username;
  first_name = other0.first_name;
  last_name = other0.last_name;
  follows_you = other0.follows_you;
  followed_by_you = other0.followed_by_you;
  n_followers = other0.n_followers;
  n_following = other0.n_following;
  n_posts = other0.n_posts;
  n_likes = other0.n_likes;
  __isset = other0.__isset;
}
TAccount& TAccount::operator=(const TAccount& other1) {
  id = other1.id;
  created_at = other1.created_at;
  active = other1.active;
  username = other1.username;
  first_name = other1.first_name;
  last_name = other1.last_name;
  follows_you = other1.follows_you;
  followed_by_you = other1.followed_by_you;
  n_followers = other1.n_followers;
  n_following = other1.n_following;
  n_posts = other1.n_posts;
  n_likes = other1.n_likes;
  __isset = other1.__isset;
  return *this;
}
void TAccount::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAccount(";
  out << "id=" << to_string(id);
  out << ", " << "created_at=" << to_string(created_at);
  out << ", " << "active=" << to_string(active);
  out << ", " << "username=" << to_string(username);
  out << ", " << "first_name=" << to_string(first_name);
  out << ", " << "last_name=" << to_string(last_name);
  out << ", " << "follows_you="; (__isset.follows_you ? (out << to_string(follows_you)) : (out << "<null>"));
  out << ", " << "followed_by_you="; (__isset.followed_by_you ? (out << to_string(followed_by_you)) : (out << "<null>"));
  out << ", " << "n_followers="; (__isset.n_followers ? (out << to_string(n_followers)) : (out << "<null>"));
  out << ", " << "n_following="; (__isset.n_following ? (out << to_string(n_following)) : (out << "<null>"));
  out << ", " << "n_posts="; (__isset.n_posts ? (out << to_string(n_posts)) : (out << "<null>"));
  out << ", " << "n_likes="; (__isset.n_likes ? (out << to_string(n_likes)) : (out << "<null>"));
  out << ")";
}


TFollow::~TFollow() noexcept {
}


void TFollow::__set_id(const int32_t val) {
  this->id = val;
}

void TFollow::__set_created_at(const int32_t val) {
  this->created_at = val;
}

void TFollow::__set_follower_id(const int32_t val) {
  this->follower_id = val;
}

void TFollow::__set_followee_id(const int32_t val) {
  this->followee_id = val;
}

void TFollow::__set_follower(const TAccount& val) {
  this->follower = val;
__isset.follower = true;
}

void TFollow::__set_followee(const TAccount& val) {
  this->followee = val;
__isset.followee = true;
}
std::ostream& operator<<(std::ostream& out, const TFollow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFollow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_created_at = false;
  bool isset_follower_id = false;
  bool isset_followee_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->created_at);
          isset_created_at = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->follower_id);
          isset_follower_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->followee_id);
          isset_followee_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->follower.read(iprot);
          this->__isset.follower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->followee.read(iprot);
          this->__isset.followee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_created_at)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_follower_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_followee_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFollow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFollow");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("created_at", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->created_at);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("follower_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->follower_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("followee_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->followee_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.follower) {
    xfer += oprot->writeFieldBegin("follower", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->follower.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.followee) {
    xfer += oprot->writeFieldBegin("followee", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->followee.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFollow &a, TFollow &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.created_at, b.created_at);
  swap(a.follower_id, b.follower_id);
  swap(a.followee_id, b.followee_id);
  swap(a.follower, b.follower);
  swap(a.followee, b.followee);
  swap(a.__isset, b.__isset);
}

TFollow::TFollow(const TFollow& other2) {
  id = other2.id;
  created_at = other2.created_at;
  follower_id = other2.follower_id;
  followee_id = other2.followee_id;
  follower = other2.follower;
  followee = other2.followee;
  __isset = other2.__isset;
}
TFollow& TFollow::operator=(const TFollow& other3) {
  id = other3.id;
  created_at = other3.created_at;
  follower_id = other3.follower_id;
  followee_id = other3.followee_id;
  follower = other3.follower;
  followee = other3.followee;
  __isset = other3.__isset;
  return *this;
}
void TFollow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFollow(";
  out << "id=" << to_string(id);
  out << ", " << "created_at=" << to_string(created_at);
  out << ", " << "follower_id=" << to_string(follower_id);
  out << ", " << "followee_id=" << to_string(followee_id);
  out << ", " << "follower="; (__isset.follower ? (out << to_string(follower)) : (out << "<null>"));
  out << ", " << "followee="; (__isset.followee ? (out << to_string(followee)) : (out << "<null>"));
  out << ")";
}


TFollowQuery::~TFollowQuery() noexcept {
}


void TFollowQuery::__set_follower_id(const int32_t val) {
  this->follower_id = val;
__isset.follower_id = true;
}

void TFollowQuery::__set_followee_id(const int32_t val) {
  this->followee_id = val;
__isset.followee_id = true;
}
std::ostream& operator<<(std::ostream& out, const TFollowQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFollowQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->follower_id);
          this->__isset.follower_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->followee_id);
          this->__isset.followee_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TFollowQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFollowQuery");

  if (this->__isset.follower_id) {
    xfer += oprot->writeFieldBegin("follower_id", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->follower_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.followee_id) {
    xfer += oprot->writeFieldBegin("followee_id", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->followee_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFollowQuery &a, TFollowQuery &b) {
  using ::std::swap;
  swap(a.follower_id, b.follower_id);
  swap(a.followee_id, b.followee_id);
  swap(a.__isset, b.__isset);
}

TFollowQuery::TFollowQuery(const TFollowQuery& other4) {
  follower_id = other4.follower_id;
  followee_id = other4.followee_id;
  __isset = other4.__isset;
}
TFollowQuery& TFollowQuery::operator=(const TFollowQuery& other5) {
  follower_id = other5.follower_id;
  followee_id = other5.followee_id;
  __isset = other5.__isset;
  return *this;
}
void TFollowQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFollowQuery(";
  out << "follower_id="; (__isset.follower_id ? (out << to_string(follower_id)) : (out << "<null>"));
  out << ", " << "followee_id="; (__isset.followee_id ? (out << to_string(followee_id)) : (out << "<null>"));
  out << ")";
}


TPost::~TPost() noexcept {
}


void TPost::__set_id(const int32_t val) {
  this->id = val;
}

void TPost::__set_created_at(const int32_t val) {
  this->created_at = val;
}

void TPost::__set_active(const bool val) {
  this->active = val;
}

void TPost::__set_text(const std::string& val) {
  this->text = val;
}

void TPost::__set_author_id(const int32_t val) {
  this->author_id = val;
}

void TPost::__set_author(const TAccount& val) {
  this->author = val;
__isset.author = true;
}

void TPost::__set_n_likes(const int32_t val) {
  this->n_likes = val;
__isset.n_likes = true;
}
std::ostream& operator<<(std::ostream& out, const TPost& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPost::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_created_at = false;
  bool isset_active = false;
  bool isset_text = false;
  bool isset_author_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->created_at);
          isset_created_at = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->active);
          isset_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          isset_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->author_id);
          isset_author_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->author.read(iprot);
          this->__isset.author = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->n_likes);
          this->__isset.n_likes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_created_at)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_active)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_text)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_author_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPost::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPost");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("created_at", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->created_at);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("active", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->active);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("author_id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->author_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.author) {
    xfer += oprot->writeFieldBegin("author", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->author.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.n_likes) {
    xfer += oprot->writeFieldBegin("n_likes", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->n_likes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPost &a, TPost &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.created_at, b.created_at);
  swap(a.active, b.active);
  swap(a.text, b.text);
  swap(a.author_id, b.author_id);
  swap(a.author, b.author);
  swap(a.n_likes, b.n_likes);
  swap(a.__isset, b.__isset);
}

TPost::TPost(const TPost& other6) {
  id = other6.id;
  created_at = other6.created_at;
  active = other6.active;
  text = other6.text;
  author_id = other6.author_id;
  author = other6.author;
  n_likes = other6.n_likes;
  __isset = other6.__isset;
}
TPost& TPost::operator=(const TPost& other7) {
  id = other7.id;
  created_at = other7.created_at;
  active = other7.active;
  text = other7.text;
  author_id = other7.author_id;
  author = other7.author;
  n_likes = other7.n_likes;
  __isset = other7.__isset;
  return *this;
}
void TPost::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPost(";
  out << "id=" << to_string(id);
  out << ", " << "created_at=" << to_string(created_at);
  out << ", " << "active=" << to_string(active);
  out << ", " << "text=" << to_string(text);
  out << ", " << "author_id=" << to_string(author_id);
  out << ", " << "author="; (__isset.author ? (out << to_string(author)) : (out << "<null>"));
  out << ", " << "n_likes="; (__isset.n_likes ? (out << to_string(n_likes)) : (out << "<null>"));
  out << ")";
}


TLike::~TLike() noexcept {
}


void TLike::__set_id(const int32_t val) {
  this->id = val;
}

void TLike::__set_created_at(const int32_t val) {
  this->created_at = val;
}

void TLike::__set_account_id(const int32_t val) {
  this->account_id = val;
}

void TLike::__set_post_id(const int32_t val) {
  this->post_id = val;
}

void TLike::__set_account(const TAccount& val) {
  this->account = val;
}

void TLike::__set_post(const TPost& val) {
  this->post = val;
}
std::ostream& operator<<(std::ostream& out, const TLike& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLike::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_created_at = false;
  bool isset_account_id = false;
  bool isset_post_id = false;
  bool isset_account = false;
  bool isset_post = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->created_at);
          isset_created_at = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->account_id);
          isset_account_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->post_id);
          isset_post_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->account.read(iprot);
          isset_account = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->post.read(iprot);
          isset_post = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_created_at)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_account_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_post_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_account)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_post)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLike::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLike");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("created_at", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->created_at);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("account_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->account_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->post_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->account.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->post.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLike &a, TLike &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.created_at, b.created_at);
  swap(a.account_id, b.account_id);
  swap(a.post_id, b.post_id);
  swap(a.account, b.account);
  swap(a.post, b.post);
}

TLike::TLike(const TLike& other8) {
  id = other8.id;
  created_at = other8.created_at;
  account_id = other8.account_id;
  post_id = other8.post_id;
  account = other8.account;
  post = other8.post;
}
TLike& TLike::operator=(const TLike& other9) {
  id = other9.id;
  created_at = other9.created_at;
  account_id = other9.account_id;
  post_id = other9.post_id;
  account = other9.account;
  post = other9.post;
  return *this;
}
void TLike::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLike(";
  out << "id=" << to_string(id);
  out << ", " << "created_at=" << to_string(created_at);
  out << ", " << "account_id=" << to_string(account_id);
  out << ", " << "post_id=" << to_string(post_id);
  out << ", " << "account=" << to_string(account);
  out << ", " << "post=" << to_string(post);
  out << ")";
}


TUniquepair::~TUniquepair() noexcept {
}


void TUniquepair::__set_id(const int32_t val) {
  this->id = val;
}

void TUniquepair::__set_created_at(const int32_t val) {
  this->created_at = val;
}

void TUniquepair::__set_domain(const std::string& val) {
  this->domain = val;
}

void TUniquepair::__set_first_elem(const int32_t val) {
  this->first_elem = val;
}

void TUniquepair::__set_second_elem(const int32_t val) {
  this->second_elem = val;
}
std::ostream& operator<<(std::ostream& out, const TUniquepair& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUniquepair::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_created_at = false;
  bool isset_domain = false;
  bool isset_first_elem = false;
  bool isset_second_elem = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->created_at);
          isset_created_at = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          isset_domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->first_elem);
          isset_first_elem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->second_elem);
          isset_second_elem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_created_at)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_domain)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_first_elem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_second_elem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUniquepair::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUniquepair");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("created_at", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->created_at);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->domain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first_elem", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->first_elem);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("second_elem", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->second_elem);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUniquepair &a, TUniquepair &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.created_at, b.created_at);
  swap(a.domain, b.domain);
  swap(a.first_elem, b.first_elem);
  swap(a.second_elem, b.second_elem);
}

TUniquepair::TUniquepair(const TUniquepair& other10) {
  id = other10.id;
  created_at = other10.created_at;
  domain = other10.domain;
  first_elem = other10.first_elem;
  second_elem = other10.second_elem;
}
TUniquepair& TUniquepair::operator=(const TUniquepair& other11) {
  id = other11.id;
  created_at = other11.created_at;
  domain = other11.domain;
  first_elem = other11.first_elem;
  second_elem = other11.second_elem;
  return *this;
}
void TUniquepair::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUniquepair(";
  out << "id=" << to_string(id);
  out << ", " << "created_at=" << to_string(created_at);
  out << ", " << "domain=" << to_string(domain);
  out << ", " << "first_elem=" << to_string(first_elem);
  out << ", " << "second_elem=" << to_string(second_elem);
  out << ")";
}


TUniquepairQuery::~TUniquepairQuery() noexcept {
}


void TUniquepairQuery::__set_domain(const std::string& val) {
  this->domain = val;
}

void TUniquepairQuery::__set_first_elem(const int32_t val) {
  this->first_elem = val;
__isset.first_elem = true;
}

void TUniquepairQuery::__set_second_elem(const int32_t val) {
  this->second_elem = val;
__isset.second_elem = true;
}
std::ostream& operator<<(std::ostream& out, const TUniquepairQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUniquepairQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_domain = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          isset_domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->first_elem);
          this->__isset.first_elem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->second_elem);
          this->__isset.second_elem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_domain)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUniquepairQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUniquepairQuery");

  xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->domain);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.first_elem) {
    xfer += oprot->writeFieldBegin("first_elem", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->first_elem);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.second_elem) {
    xfer += oprot->writeFieldBegin("second_elem", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->second_elem);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUniquepairQuery &a, TUniquepairQuery &b) {
  using ::std::swap;
  swap(a.domain, b.domain);
  swap(a.first_elem, b.first_elem);
  swap(a.second_elem, b.second_elem);
  swap(a.__isset, b.__isset);
}

TUniquepairQuery::TUniquepairQuery(const TUniquepairQuery& other12) {
  domain = other12.domain;
  first_elem = other12.first_elem;
  second_elem = other12.second_elem;
  __isset = other12.__isset;
}
TUniquepairQuery& TUniquepairQuery::operator=(const TUniquepairQuery& other13) {
  domain = other13.domain;
  first_elem = other13.first_elem;
  second_elem = other13.second_elem;
  __isset = other13.__isset;
  return *this;
}
void TUniquepairQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUniquepairQuery(";
  out << "domain=" << to_string(domain);
  out << ", " << "first_elem="; (__isset.first_elem ? (out << to_string(first_elem)) : (out << "<null>"));
  out << ", " << "second_elem="; (__isset.second_elem ? (out << to_string(second_elem)) : (out << "<null>"));
  out << ")";
}


TAccountInvalidCredentialsException::~TAccountInvalidCredentialsException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TAccountInvalidCredentialsException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAccountInvalidCredentialsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAccountInvalidCredentialsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAccountInvalidCredentialsException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAccountInvalidCredentialsException &a, TAccountInvalidCredentialsException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TAccountInvalidCredentialsException::TAccountInvalidCredentialsException(const TAccountInvalidCredentialsException& other14) : TException() {
  (void) other14;
}
TAccountInvalidCredentialsException& TAccountInvalidCredentialsException::operator=(const TAccountInvalidCredentialsException& other15) {
  (void) other15;
  return *this;
}
void TAccountInvalidCredentialsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAccountInvalidCredentialsException(";
  out << ")";
}

const char* TAccountInvalidCredentialsException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TAccountInvalidCredentialsException";
  }
}


TAccountDeactivatedException::~TAccountDeactivatedException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TAccountDeactivatedException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAccountDeactivatedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAccountDeactivatedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAccountDeactivatedException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAccountDeactivatedException &a, TAccountDeactivatedException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TAccountDeactivatedException::TAccountDeactivatedException(const TAccountDeactivatedException& other16) : TException() {
  (void) other16;
}
TAccountDeactivatedException& TAccountDeactivatedException::operator=(const TAccountDeactivatedException& other17) {
  (void) other17;
  return *this;
}
void TAccountDeactivatedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAccountDeactivatedException(";
  out << ")";
}

const char* TAccountDeactivatedException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TAccountDeactivatedException";
  }
}


TAccountInvalidAttributesException::~TAccountInvalidAttributesException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TAccountInvalidAttributesException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAccountInvalidAttributesException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAccountInvalidAttributesException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAccountInvalidAttributesException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAccountInvalidAttributesException &a, TAccountInvalidAttributesException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TAccountInvalidAttributesException::TAccountInvalidAttributesException(const TAccountInvalidAttributesException& other18) : TException() {
  (void) other18;
}
TAccountInvalidAttributesException& TAccountInvalidAttributesException::operator=(const TAccountInvalidAttributesException& other19) {
  (void) other19;
  return *this;
}
void TAccountInvalidAttributesException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAccountInvalidAttributesException(";
  out << ")";
}

const char* TAccountInvalidAttributesException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TAccountInvalidAttributesException";
  }
}


TAccountUsernameAlreadyExistsException::~TAccountUsernameAlreadyExistsException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TAccountUsernameAlreadyExistsException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAccountUsernameAlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAccountUsernameAlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAccountUsernameAlreadyExistsException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAccountUsernameAlreadyExistsException &a, TAccountUsernameAlreadyExistsException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TAccountUsernameAlreadyExistsException::TAccountUsernameAlreadyExistsException(const TAccountUsernameAlreadyExistsException& other20) : TException() {
  (void) other20;
}
TAccountUsernameAlreadyExistsException& TAccountUsernameAlreadyExistsException::operator=(const TAccountUsernameAlreadyExistsException& other21) {
  (void) other21;
  return *this;
}
void TAccountUsernameAlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAccountUsernameAlreadyExistsException(";
  out << ")";
}

const char* TAccountUsernameAlreadyExistsException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TAccountUsernameAlreadyExistsException";
  }
}


TAccountNotFoundException::~TAccountNotFoundException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TAccountNotFoundException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAccountNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAccountNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAccountNotFoundException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAccountNotFoundException &a, TAccountNotFoundException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TAccountNotFoundException::TAccountNotFoundException(const TAccountNotFoundException& other22) : TException() {
  (void) other22;
}
TAccountNotFoundException& TAccountNotFoundException::operator=(const TAccountNotFoundException& other23) {
  (void) other23;
  return *this;
}
void TAccountNotFoundException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAccountNotFoundException(";
  out << ")";
}

const char* TAccountNotFoundException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TAccountNotFoundException";
  }
}


TAccountNotAuthorizedException::~TAccountNotAuthorizedException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TAccountNotAuthorizedException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAccountNotAuthorizedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAccountNotAuthorizedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAccountNotAuthorizedException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAccountNotAuthorizedException &a, TAccountNotAuthorizedException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TAccountNotAuthorizedException::TAccountNotAuthorizedException(const TAccountNotAuthorizedException& other24) : TException() {
  (void) other24;
}
TAccountNotAuthorizedException& TAccountNotAuthorizedException::operator=(const TAccountNotAuthorizedException& other25) {
  (void) other25;
  return *this;
}
void TAccountNotAuthorizedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAccountNotAuthorizedException(";
  out << ")";
}

const char* TAccountNotAuthorizedException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TAccountNotAuthorizedException";
  }
}


TFollowAlreadyExistsException::~TFollowAlreadyExistsException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TFollowAlreadyExistsException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFollowAlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TFollowAlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFollowAlreadyExistsException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFollowAlreadyExistsException &a, TFollowAlreadyExistsException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TFollowAlreadyExistsException::TFollowAlreadyExistsException(const TFollowAlreadyExistsException& other26) : TException() {
  (void) other26;
}
TFollowAlreadyExistsException& TFollowAlreadyExistsException::operator=(const TFollowAlreadyExistsException& other27) {
  (void) other27;
  return *this;
}
void TFollowAlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFollowAlreadyExistsException(";
  out << ")";
}

const char* TFollowAlreadyExistsException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TFollowAlreadyExistsException";
  }
}


TFollowNotFoundException::~TFollowNotFoundException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TFollowNotFoundException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFollowNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TFollowNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFollowNotFoundException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFollowNotFoundException &a, TFollowNotFoundException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TFollowNotFoundException::TFollowNotFoundException(const TFollowNotFoundException& other28) : TException() {
  (void) other28;
}
TFollowNotFoundException& TFollowNotFoundException::operator=(const TFollowNotFoundException& other29) {
  (void) other29;
  return *this;
}
void TFollowNotFoundException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFollowNotFoundException(";
  out << ")";
}

const char* TFollowNotFoundException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TFollowNotFoundException";
  }
}


TFollowNotAuthorizedException::~TFollowNotAuthorizedException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TFollowNotAuthorizedException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFollowNotAuthorizedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TFollowNotAuthorizedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFollowNotAuthorizedException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFollowNotAuthorizedException &a, TFollowNotAuthorizedException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TFollowNotAuthorizedException::TFollowNotAuthorizedException(const TFollowNotAuthorizedException& other30) : TException() {
  (void) other30;
}
TFollowNotAuthorizedException& TFollowNotAuthorizedException::operator=(const TFollowNotAuthorizedException& other31) {
  (void) other31;
  return *this;
}
void TFollowNotAuthorizedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFollowNotAuthorizedException(";
  out << ")";
}

const char* TFollowNotAuthorizedException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TFollowNotAuthorizedException";
  }
}


TLikeAlreadyExistsException::~TLikeAlreadyExistsException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TLikeAlreadyExistsException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLikeAlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TLikeAlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLikeAlreadyExistsException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLikeAlreadyExistsException &a, TLikeAlreadyExistsException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TLikeAlreadyExistsException::TLikeAlreadyExistsException(const TLikeAlreadyExistsException& other32) : TException() {
  (void) other32;
}
TLikeAlreadyExistsException& TLikeAlreadyExistsException::operator=(const TLikeAlreadyExistsException& other33) {
  (void) other33;
  return *this;
}
void TLikeAlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLikeAlreadyExistsException(";
  out << ")";
}

const char* TLikeAlreadyExistsException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TLikeAlreadyExistsException";
  }
}


TLikeNotFoundException::~TLikeNotFoundException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TLikeNotFoundException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLikeNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TLikeNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLikeNotFoundException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLikeNotFoundException &a, TLikeNotFoundException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TLikeNotFoundException::TLikeNotFoundException(const TLikeNotFoundException& other34) : TException() {
  (void) other34;
}
TLikeNotFoundException& TLikeNotFoundException::operator=(const TLikeNotFoundException& other35) {
  (void) other35;
  return *this;
}
void TLikeNotFoundException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLikeNotFoundException(";
  out << ")";
}

const char* TLikeNotFoundException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TLikeNotFoundException";
  }
}


TLikeNotAuthorizedException::~TLikeNotAuthorizedException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TLikeNotAuthorizedException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLikeNotAuthorizedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TLikeNotAuthorizedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLikeNotAuthorizedException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLikeNotAuthorizedException &a, TLikeNotAuthorizedException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TLikeNotAuthorizedException::TLikeNotAuthorizedException(const TLikeNotAuthorizedException& other36) : TException() {
  (void) other36;
}
TLikeNotAuthorizedException& TLikeNotAuthorizedException::operator=(const TLikeNotAuthorizedException& other37) {
  (void) other37;
  return *this;
}
void TLikeNotAuthorizedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLikeNotAuthorizedException(";
  out << ")";
}

const char* TLikeNotAuthorizedException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TLikeNotAuthorizedException";
  }
}


TPostInvalidAttributesException::~TPostInvalidAttributesException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TPostInvalidAttributesException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPostInvalidAttributesException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPostInvalidAttributesException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPostInvalidAttributesException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPostInvalidAttributesException &a, TPostInvalidAttributesException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TPostInvalidAttributesException::TPostInvalidAttributesException(const TPostInvalidAttributesException& other38) : TException() {
  (void) other38;
}
TPostInvalidAttributesException& TPostInvalidAttributesException::operator=(const TPostInvalidAttributesException& other39) {
  (void) other39;
  return *this;
}
void TPostInvalidAttributesException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPostInvalidAttributesException(";
  out << ")";
}

const char* TPostInvalidAttributesException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TPostInvalidAttributesException";
  }
}


TPostNotFoundException::~TPostNotFoundException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TPostNotFoundException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPostNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPostNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPostNotFoundException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPostNotFoundException &a, TPostNotFoundException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TPostNotFoundException::TPostNotFoundException(const TPostNotFoundException& other40) : TException() {
  (void) other40;
}
TPostNotFoundException& TPostNotFoundException::operator=(const TPostNotFoundException& other41) {
  (void) other41;
  return *this;
}
void TPostNotFoundException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPostNotFoundException(";
  out << ")";
}

const char* TPostNotFoundException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TPostNotFoundException";
  }
}


TPostNotAuthorizedException::~TPostNotAuthorizedException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TPostNotAuthorizedException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPostNotAuthorizedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPostNotAuthorizedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPostNotAuthorizedException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPostNotAuthorizedException &a, TPostNotAuthorizedException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TPostNotAuthorizedException::TPostNotAuthorizedException(const TPostNotAuthorizedException& other42) : TException() {
  (void) other42;
}
TPostNotAuthorizedException& TPostNotAuthorizedException::operator=(const TPostNotAuthorizedException& other43) {
  (void) other43;
  return *this;
}
void TPostNotAuthorizedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPostNotAuthorizedException(";
  out << ")";
}

const char* TPostNotAuthorizedException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TPostNotAuthorizedException";
  }
}


TUniquepairNotFoundException::~TUniquepairNotFoundException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TUniquepairNotFoundException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUniquepairNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TUniquepairNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUniquepairNotFoundException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUniquepairNotFoundException &a, TUniquepairNotFoundException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TUniquepairNotFoundException::TUniquepairNotFoundException(const TUniquepairNotFoundException& other44) : TException() {
  (void) other44;
}
TUniquepairNotFoundException& TUniquepairNotFoundException::operator=(const TUniquepairNotFoundException& other45) {
  (void) other45;
  return *this;
}
void TUniquepairNotFoundException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUniquepairNotFoundException(";
  out << ")";
}

const char* TUniquepairNotFoundException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TUniquepairNotFoundException";
  }
}


TUniquepairAlreadyExistsException::~TUniquepairAlreadyExistsException() noexcept {
}

std::ostream& operator<<(std::ostream& out, const TUniquepairAlreadyExistsException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUniquepairAlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TUniquepairAlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUniquepairAlreadyExistsException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUniquepairAlreadyExistsException &a, TUniquepairAlreadyExistsException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TUniquepairAlreadyExistsException::TUniquepairAlreadyExistsException(const TUniquepairAlreadyExistsException& other46) : TException() {
  (void) other46;
}
TUniquepairAlreadyExistsException& TUniquepairAlreadyExistsException::operator=(const TUniquepairAlreadyExistsException& other47) {
  (void) other47;
  return *this;
}
void TUniquepairAlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUniquepairAlreadyExistsException(";
  out << ")";
}

const char* TUniquepairAlreadyExistsException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TUniquepairAlreadyExistsException";
  }
}

} // namespace
